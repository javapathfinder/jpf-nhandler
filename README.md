# jpf-nhandler

jpf-nhandler is an extension of **Java PathFinder (JPF)** that automatically delegates the execution of selected methods from JPF to the host JVM.

When a method call `o.m(a)` is delegated, jpf-nhandler performs the following steps:

1. Transforms the JPF representation of the object `o` and arguments `a` to their host JVM representations.
2. Delegates execution to the original (native or non-native) method `m` on the host JVM.
3. Transforms the result of the method call back to its JPF representation.

The implementation of jpf-nhandler mainly relies on **MJI (Model Java Interface)**. Native peers are generated on-the-fly using the **BCEL** library. These generated peers are referred to as **on-the-fly (OTF) peers**.

---

## Main Applications

jpf-nhandler is primarily used for the following purposes:

1. **Automatic handling of native calls**  
   Intercepts and handles native calls within JPF, allowing verification of systems that would otherwise crash.

2. **Reducing state space**  
   Delegated calls are executed outside JPF, reducing state explosion and improving scalability.

3. **Avoiding memory exhaustion**  
   Long execution traces may cause JPF to run out of memory. Delegating such methods prevents this issue.

4. **Performance improvement**  
   Delegating methods may also speed up JPF execution.

---

## Requirements

- **Java 11 (recommended)**
  - Java 8 may still work, but Java 11 is the primary supported version
- Git
- Gradle (via the included Gradle wrapper)
- `jpf-core` installed and built

To check your Java version:

```bash
java -version
```
Project Structure
-----------------
```
jpf-nhandler/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â””â”€â”€ java/        # jpf-nhandler implementation
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/        # unit tests
â”œâ”€â”€ onthefly/
â”‚   â”œâ”€â”€ *.java           # generated on-the-fly native peer sources
â”‚   â””â”€â”€ *.class          # generated bytecode
â”œâ”€â”€ build.gradle
â””â”€â”€ README.md
```
1.src/main/java contains the core implementation.
2.src/test/java contains unit tests.
3.onthefly/ stores generated native peer sources and bytecode (optional).

Installing jpf-nhandler
-----------------------
1. Install jpf-core

Install jpf-core by following the instructions on the jpf-core wiki.
Cloning the master branch and building with the Gradle wrapper is recommended.

Note: Some jpf-core tests may fail. This does not prevent using JPF.

2. Clone jpf-nhandler
```
git clone https://github.com/javapathfinder/jpf-nhandler.git
cd jpf-nhandler
```
3. Build jpf-nhandler
```
./gradlew build
```

Warnings related to internal Java APIs may appear and are expected.

4. Run Tests
```
./gradlew test
```

Expected result:

a.All tests pass
b.No failures or skipped tests

5. Register jpf-nhandler

Add jpf-nhandler to your site.properties file.
Refer to the jpf-core documentation for details.

Running JPF with jpf-nhandler
----------------------------
To run JPF with jpf-nhandler enabled, include the following in your .jpf file:
```
@using = jpf-nhandler

target = Example

nhandler.delegateUnhandledNative = true

classpath = path-to-application-classes
native_classpath = path-to-application-classes

```

Important Note on Classpaths
----------------------------
Classes belonging to the System Under Test (SUT) must be accessible to both:
1.JPF (classpath)
2.Host JVM (native_classpath)

Since execution alternates between JPF and the host JVM, the same directories or JAR files must be specified for both properties.


Configuration Options
---------------------
1.Delegating Methods

Delegate a specific constructor:
```
nhandler.spec.delegate = a.b.C.<init>
```

Delegate all methods of a class:
```
nhandler.spec.delegate = java.lang.String.*
```
2.Skipping Methods

Skip a method (executed as empty and returns a dummy value):
```
nhandler.spec.skip = java.io.FileDescriptor.write
```
3.Delegate Only Unhandled Native Calls
```
nhandler.delegateUnhandledNative = true
```
4.On-the-Fly Native Peers
```
jpf-nhandler generates native peers dynamically.
```
Generated peers are stored in:
```
jpf-nhandler/onthefly/
```
5.Generate Source Code for OTF Peers
```
nhandler.genSource = true
```
6.Compile Generated Sources Manually
```
javac -cp "<JPF_HOME>/build/jpf.jar:<NHANDLER_HOME>/build/jpf-nhandler.jar" onthefly/*.java
```
7.Reuse Generated Peers Across Runs

Since on-the-fly bytecode generation is expensive, peers can be reused:
```
nhandler.clean = false
```


Limitations of jpf-nhandler
---------------------------

  1. Platform-specific classes (e.g., java.lang.System) cannot be handled due to inconsistencies between JPF and the host JVM. 

  2. Delegated objects and classes must have identical fields and superclasses in both environments.

  3. Side effects must be observable only via return values, arguments, or the invoking object.

  4. Objects with native-managed state (e.g., java.awt.Window) cannot be handled.
  5. Methods such as java.util.concurrent.locks.ReentrantLock.lock() cannot be delegated.


Licensing of jpf-nhandler
-------------------------

jpf-nhandler is free software distributed under the
GNU General Public License v3 (or later).

Licenses of third-party JAR files in lib/example are included with the project.

You can find the GNU GPL at:
http://www.gnu.org/licenses

Questions/Feedback
------------------------------

For questions, comments, or suggestions, please contact:

ðŸ“§ nastaran.shafiei@gmail.com


ACknowledgements
------

Thanks to Peter Mehlitz for his help with the development of jpf-nhandler.
